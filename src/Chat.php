<?php
// This is our custom WebSocket handler class (that implements the 'MessageComponentInterface' of the Ratchet library)
// This class is copied from: http://socketo.me/docs/hello-world#logic
// Note: If you edit/change any code that is related to the WebSocket Server (i.e. Ratchet library) (example: If you edit/change any code in Chat.php class), you must restart the WebSocket Server in order for the changes to take effect (by opening the terminal and stopping the already running WebSocket Server by CTRL + C, then starting it again by using the    "php bin/server.php"    command).

namespace MyApp;
use Ratchet\MessageComponentInterface;
use Ratchet\ConnectionInterface;
require dirname(__DIR__) . "/database/ChatUser.php";
require dirname(__DIR__) . "/database/ChatRooms.php";
require dirname(__DIR__) . "/database/PrivateChat.php";



// http://socketo.me/docs/hello-world#next_steps:~:text=We%27ll%20start%20off%20by%20creating%20a%20class.%20This%20class%20will%20be%20our%20chat%20%22application%22.%20This%20basic%20application%20will%20listen%20for%204%20events
class Chat implements MessageComponentInterface { // The 'Chat' class is our custom WebSocket handler class that implements the 'MessageComponentInterface' of the Ratchet library
    protected $clients;

    public function __construct() {
        $this->clients = new \SplObjectStorage;
        echo 'Server Started';
    }

    public function onOpen(ConnectionInterface $conn) { // Note:    $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
        /* echo '<pre>', var_dump($conn), '</pre>';
        exit; */

        // Store the new connection to send messages to later
        echo 'Server Started';

        $this->clients->attach($conn);


        // echo '<pre>', var_dump($conn->resourceId), '</pre>'; // Example:    51    // Note:    $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
        // exit;


        // Disply the Online/Offline Status of all users/clients based on the onOpen() and onClose() methods (in case of 'One-to-One/Private' Chat ONLY, not 'Group' Chat. With 'Group' Chat, we depended on the `user_login_status` column of `chat_user_table` table) (This script is repeated inside the onClose() method of this class too for the Online/Offline Status too (Online Status))
        // Note: We have the same script in onClose() method for the 'Offline' Status. Check the onClose() method for the same script
        // Note: With the 'Group' Chat (in chatroom.php), we depended on the `user_login_status` column of `chat_user_table` table to display the Online/Offline Status of all users/clients, but with the 'One-to-One/Private' Chat (in privatechat.php), we depended on the onOpen() and onClose() methods here to send the `user_id` user id and status 'Online' or 'Offline to all users/clients on the Client Side (to be handled by JavaScript in privatechat.php inside the    conn.onmessage = function(event) {    ). And of cousre, depending on the onOpen() is the best option because it means the Online/Offline is live and instantaneous, unlike the case with depending on the `user_login_status` column
        // Note: For displaying User Online/Offline Status, with 'One-to-One/Private' Chat, we depended on the onOpen() and onClose() methods of the custom WebSocket handler Chat.php class (which is the best way because it's Real-time and Instantaneous), but with the 'Group' Chat, we depended on the `user_login_status` column of the `chat_user_table` database table (which is a bad idea, because a user can just close the browser and don't click on Logout, and if they don't click on Logout, the `user_login_status` column value won't be changed, then their Online/Offline Status will be always 'Online').
        // Note: Sending data from the onOpen() and onClose() methods of the custom WebSocket Handler Chat.php Class triggers the    conn.onmessage    event in JavaScript on the client side (here in this project, in privatechat.php or chatroom.php) (i.e. It doesn't trigger the    conn.onopen    or    conn.onclose    JavaScript events!)
        // Note: With every client (user) connected to a WebSocket Connection (Ratchet library), WebSocket Connection generates and assigns every client (user) a unique connection ID (N.B. You can check that unique WebSocket identifier using     $conn->resourceId     ). And the idea of the 'One-to-One' or 'Private' Chat is based on it plus the `user_token` that we generate by ourselves with every user Login process in index.php. We can store those unique Connection IDs plust the `user_token` for every client in the database, and later we can depend on them to implement One-to-One or Private Chat. To implement the 'One-to-One' or 'Private' Chat, We use TWO table columns of the `chat_user_table`, firstly, the `user_token` column, where with every user login process we generate a unique random string using     md5(uniqid())     and then we pass this unique string as a Query String Parameter in the URL used in the client side JavaScript WebSocket constructor to start the WebSocket connection (i.e.     var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');     ). N.B.  You can check this unique string (token) by connecting to a WebSocket Connection, then use 'Inspect' in your browser console, click on the 'Network' tab, then under 'Name' you'll find something like 'ws://localhost:8080/?token=014c3972efce8dc679b25d45a2ce2bd6', you can click on it and check the 'Headers', 'Payload', 'Initiators', ... tabs), secondly, the `user_connection_id` column which is randomly generated by WebSocket for every client connected to the WebSocket Connection (AKA WebSocket Session ID). N.B. You can access this unique identifier using     $conn->resourceId     . Check     https://www.youtube.com/watch?v=PuXfgSzDDcg&list=PLxl69kCRkiI0U4rM9RA1VBah5tfU26-Fp&index=15
        // The purpose of this code is Dispaly User Online/Offline Status: In case of 'One-to-One/Private' Chat ONLY (NOT 'Group' Chat), we send the $data variable to the client side which contains 'status_type' and 'user_id_status' (the `user_id` of the user) to all clients/users, in order for every user to view the Online/Offline Status of the other users in the client side in privatechat.php
        // Important: Sending this $data array variable (using    $client->send(json_encode($data));    ) from onOpen() or onClose() methods here (we're on the server-side) triggers the    conn.onmessage    event on the client side (JavaScript) in privatechat.php i.e.    conn.onmessage = function(e) {
        // Get the unique $token (`user_token` in `chat_user_table` table) that we generated (upon every user login process in index.php using the    md5(uniqid())    functions). This $token gets passed from the client side (JavaScript) request's URL as a Query String Parameter inside the Browser/Web API WebSocket() Constructor function in privatechat.php i.e.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');
        // https://stackoverflow.com/questions/22761900/access-extra-parameters-in-ratchet-web-socket-requests
        // https://github.com/ratchetphp/Ratchet/blob/master/CHANGELOG.md#:~:text=BC%3A%20%24conn%2D%3EWebSocket%2D%3Erequest%20replaced%20with%20%24conn%2D%3EhttpRequest%20which%20is%20a%20PSR%2D7%20object
        // https://stackoverflow.com/questions/45806989/ratchetphp-no-websocket-property-for-new-connections    // Note: To access the WebSocket request's URL query string (coming from the client side (JavaScript)) on the server side (inside the custom WebSocket handler Chat.php class), check     https://stackoverflow.com/questions/45806989/ratchetphp-no-websocket-property-for-new-connections
        // https://www.google.com/search?q=%24conn-%3EhttpRequest-%3EgetUri%28%29-%3EgetQuery%28%29%3B&sca_esv=570249222&sxsrf=AM9HkKl97y-K8rdHkGb4M_im2u7kOpYpDA%3A1696308178742&ei=0psbZe_zLJGF9u8PuLeEyAo&ved=0ahUKEwjvpLGziNmBAxWRgv0HHbgbAakQ4dUDCBA&uact=5&oq=%24conn-%3EhttpRequest-%3EgetUri%28%29-%3EgetQuery%28%29%3B&gs_lp=Egxnd3Mtd2l6LXNlcnAiKSRjb25uLT5odHRwUmVxdWVzdC0-Z2V0VXJpKCktPmdldFF1ZXJ5KCk7MgUQABiiBDIFEAAYogRImrAHUKSrB1ikqwdwAngBkAEAmAGIAaABiAGqAQMwLjG4AQPIAQD4AQHCAgoQABhHGNYEGLAD4gMEGAAgQYgGAZAGAg&sclient=gws-wiz-serp
        // https://www.google.com/search?q=how+to+get+the+request+url+query+string+in+ratchet+websocket&sca_esv=570249222&sxsrf=AM9HkKlwpi0Iso1TvqttXQrAl8S8FktsVA%3A1696307641948&ei=uZkbZbigOdrg7_UP8JKviA0&ved=0ahUKEwj44LWzhtmBAxVa8LsIHXDJC9EQ4dUDCBA&uact=5&oq=how+to+get+the+request+url+query+string+in+ratchet+websocket&gs_lp=Egxnd3Mtd2l6LXNlcnAiPGhvdyB0byBnZXQgdGhlIHJlcXVlc3QgdXJsIHF1ZXJ5IHN0cmluZyBpbiByYXRjaGV0IHdlYnNvY2tldDIFECEYoAFI6jpQ2RhY6zlwCngBkAEAmAGzAaAB9BWqAQQwLjIxuAEDyAEA-AEBwgIKEAAYRxjWBBiwA8ICBhAAGBYYHsICCBAAGIoFGIYDwgIEECMYJ8ICCBAhGBYYHhgdwgIEECEYFcICBxAhGKABGAriAwQYACBBiAYBkAYI&sclient=gws-wiz-serp
        // https://www.google.com/search?q=how+to+send+messages+to+specific+clients+using+ratchet&oq=how+to+send+messages+to+specific+clients+using+ratchet&gs_lcrp=EgZjaHJvbWUyBggAEEUYOTIHCAEQIRigATIKCAIQIRgWGB0YHtIBCTE3ODU1ajBqN6gCALACAA&sourceid=chrome&ie=UTF-8
        // https://www.google.com/search?q=how+to+send+messages+to+particular+clients+using+ratchet&sca_esv=570249222&sxsrf=AM9HkKnAzRIraSgJlyTSdSHuzofbWirsDQ%3A1696308639283&ei=n50bZcL3EJKJ9u8PuZ2c4AI&ved=0ahUKEwiCw_6OitmBAxWShP0HHbkOBywQ4dUDCBA&uact=5&oq=how+to+send+messages+to+particular+clients+using+ratchet&gs_lp=Egxnd3Mtd2l6LXNlcnAiOGhvdyB0byBzZW5kIG1lc3NhZ2VzIHRvIHBhcnRpY3VsYXIgY2xpZW50cyB1c2luZyByYXRjaGV0SNAvUJsLWKotcAJ4AZABAJgBrwGgAdsLqgEEMC4xMbgBA8gBAPgBAcICChAAGEcY1gQYsAPCAgQQIRgK4gMEGAAgQYgGAZAGCA&sclient=gws-wiz-serp
        // https://www.google.com/search?q=how+to+send+messages+to+targeted+clients+in+ratchet+websocket&oq=how+to+send+messages+to+targeted+clients+in+ratchet+websocket&gs_lcrp=EgZjaHJvbWUyCAgAEEUYFRg5MgkIARAhGAoYoAEyCQgCECEYChigAdIBCTE3OTgyajBqNKgCALACAA&sourceid=chrome&ie=UTF-8
        // https://copyprogramming.com/howto/how-to-send-messages-to-particular-users-ratchet-php-websocket
        $querystring = $conn->httpRequest->getUri()->getQuery(); // Get the 'token' we ourselves generated upon user login in index.php, and then JavaScript (client side) passes it in the URL as a query string paramter in privatechat.php (i.e.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    )    // Example:    token=014c3972efce8dc679b25d45a2ce2bd6
        // echo '<pre>', var_dump($querystring), '</pre>';
        // echo '<pre>', var_dump($conn), '</pre>';
        // echo '<pre>', var_dump($conn->httpRequest), '</pre>';
        // echo '<pre>', var_dump($conn->httpRequest->getUri()), '</pre>';
        // exit;


        parse_str($querystring, $queryarray); // Example:    [ "token" => "014c3972efce8dc679b25d45a2ce2bd6" ]
        // echo '<pre>', var_dump($querystring), '</pre>'; // Example:    "token=014c3972efce8dc679b25d45a2ce2bd6"
        // echo '<pre>', var_dump($queryarray), '</pre>';  // Example:    [ "token" => "014c3972efce8dc679b25d45a2ce2bd6" ]
        // exit;

        if (isset($queryarray['token'])) // Display User Online/Offline Status in case of 'One-to-One/Private' Chat    // If the chat is 'One-to-One' or 'Private' Chat (not 'Group' Chat) i.e. The JavaScript WebSocket Constructor function URL contains a 'token' as a query string parameter e.g.    var conn = new WebSocket('ws://localhost:8080?token=<?php echo $token; >');    (which comes from the JavaScript in privatechat.php)
        {
            $user_object = new \ChatUser;

            $user_object->setUserToken($queryarray['token']); // We set the 'token' in order to use it to get the `user_id` from `chat_user_table` table (by using the    get_user_id_from_token()    method)
            $user_object->setUserConnectionId($conn->resourceId); // Note:    $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
            $user_object->update_user_connection_id(); // Store the unique WebSocket Connection ID (also AKA Session ID) of the client (user) in the `user_connection_id` column in `chat_user_table` table which is generated by the WebSocket Connection for every client (user)
            $user_data = $user_object->get_user_id_from_token(); // We use this method as we have previously set the user's token using    setUserToken()    method in the last couple of lines of code
            // echo '<pre>', var_dump($user_data), '</pre>';
            // exit;

            $user_id = $user_data['user_id'];

            $data['status_type']    = 'Online'; // Append 'status_type'    to the $data array to be sent to the client side to display real-time User Online/Offline Status
            $data['user_id_status'] = $user_id; // Append 'user_id_status' to the $data array to be sent to the client side to display real-time User Online/Offline Status

            /* echo '<pre>', var_dump($data), '</pre>';
            exit; */

            // first, you are sending to all existing users message of 'new'
            foreach ($this->clients as $client)
            {
                // Important: Sending this $data array variable (using    $client->send(json_encode($data));    ) from onOpen() or onClose() methods here (we're on the server-side) triggers the    conn.onmessage    event on the client side (JavaScript) in privatechat.php i.e.    conn.onmessage = function(e) {
                $client->send(json_encode($data)); // here we are sending a status-message    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in chatroom.php
            }
        }

        // $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
        // echo '<pre>', var_dump($conn->resourceId), '</pre>'; // Example:    51
        echo "New connection! ({$conn->resourceId})\n"; // $conn->resourceId    is a unique identifier generated by the WebSocket Server for every connected client (user) (is also called WebSocket Session ID)
    }

    public function onMessage(ConnectionInterface $from, $msg) { // $from and $msg (they are the 'userId' key and 'msg' key of the 'data' JavaScript object in chatroom.php) inside the JavaScript 'data' variable in chatroom.php) are sent by JavaScript (under the "Handling Chat HTML Form Submission" Section in chatroom.php) using the    conn.send()    function in chatroom.php    // This method is triggered when a chat message is sent from the client side chatroom.php (via JavaScript in the <script> tag), then it takes this message and, in turn, it sends it to all other clients (receivers), including the sender themselves    // $from and $msg    are the JSON 'data' JavaScript Object (converted to JSON) sent from the client side WebSocket ($from is the 'userId' key, and $msg is the 'msg' key that are sent from client side (JavaScript) when the Chat HTML Form is submitted using JavaScript in chatroom.php or privatechat.php. Check the <script> HTML tag in the same file (Under the "Handling Chat HTML Form Submission" Section in chatroom.php)), and it's passed on (sent again) to all other connected users' client side (i.e. Browser/JavaScript) (it's sent again to all users's client side (Browser/JavaScript) connected to the chat WebSocket)
        // echo '<pre>', var_dump($msg), '</pre>'; // Note: If you edit/change any code that is related to the WebSocket Server (i.e. Ratchet library) (example: If you edit/change any code in Chat.php class), you must restart the WebSocket Server in order for the changes to take effect (by opening the terminal and stopping the already running WebSocket Server by CTRL + C, then starting it again by using the    "php bin/server.php"    command).    // Example (JSON):     "{"userId":"11", "msg":"how are you?"}"    // This $msg (of JSON type) is sent from the client side (JavaScript) in chatroom.php
        // exit;

        // echo '<pre>', var_dump($from), '</pre>';
        // echo '<pre>', var_dump($from->resourceId), '</pre>';
        // exit;

        /* echo '<pre>', var_dump($this->clients), '</pre>';
        exit; */

        $numRecv = count($this->clients) - 1;
        echo sprintf('Connection %d sending message "%s" to %d other connection%s' . "\n" // This message is printed (echo-ed) inside your WebSocket Server's terminal/command-line window / Command Line window
            , $from->resourceId, $msg, $numRecv, $numRecv == 1 ? '' : 's');

        // echo '<pre>', var_dump($from->resourceId), '</pre>'; // Example:    11
        // exit;


        $data = json_decode($msg, true); // Convert $msg from JSON to a PHP array    // Example (PHP array):    ['userId' => 11, 'msg' => 'how are you?']    // This $msg (of JSON type, then we converted it to a PHP array) is sent from the client side (JavaScript) in chatroom.php
        // echo '<pre>', var_dump($data), '</pre>'; // Note: If you edit any code that is related to the WebSocket Server (i.e. Ratchet library) (example: If you edit any code in Chat.php class), you must restart the WebSocket Server in order for the changes to take effect (by opening the terminal and stopping the already running WebSocket Server by CTRL+C, then starting it again by using the    "php bin/server.php"    command)
        // exit;


        // One-to-One/Private Chat
        // if ($data['command'] == 'private')
        if (isset($data['command']) && $data['command'] == 'private')
        {
            // Private Chat
            $private_chat_object = new \PrivateChat; // To store 'One-to-One/Private' Chat messages in the `chat_message` database table (to display the Chat History)

            $private_chat_object->setToUserId($data['receiver_userid']); // Private Message Sender's   `to_user_id`   in `chat_message` table
            $private_chat_object->setFromUserId($data['userId']);        // Private Message Receiver's `from_user_id` in `chat_message` table
            $private_chat_object->setChatMessage($data['msg']);
            $timestamp = date('Y-m-d h:i:s');
            $private_chat_object->setTimestamp($timestamp);
            $private_chat_object->setStatus('Yes');
            $chat_message_id = $private_chat_object->save_chat();


            $user_object = new \ChatUser;
            $user_object->setUserId($data['userId']);
            $sender_user_data = $user_object->get_user_data_by_id();
            $user_object->setUserId($data['receiver_userid']);
            $receiver_user_data = $user_object->get_user_data_by_id();
            $sender_user_name = $sender_user_data['user_name'];
            $data['datetime'] = $timestamp;
            $receiver_user_connection_id = $receiver_user_data['user_connection_id'];

            foreach ($this->clients as $client)
            {
                // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                if ($from == $client)
                {
                    $data['from'] = 'Me'; // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }
                else
                {
                    $data['from'] = $sender_user_name; // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }

                if ($client->resourceId == $receiver_user_connection_id || $from == $client)
                {   
                    $client->send(json_encode($data)); // The sender is not the receiver, send to each client connected    // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in chatroom.php
                }
                else
                {
                    $private_chat_object->setStatus('No');
                    $private_chat_object->setChatMessageId($chat_message_id);
                    $private_chat_object->update_chat_status();
                }
            }
        }
        else // Group Chat
        {
            // Group Chat
            $chat_object = new \ChatRooms; // To store the chat messages in the `chatrooms` database table (to display the Chat History)

            $chat_object->setUserId($data['userId']); // 'userId' which came from the client side (JavaScript) in chatroom.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in chatroom.php)
            $chat_object->setMessage($data['msg']);   // 'msg'    which came from the client side (JavaScript) in chatroom.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in chatroom.php)
            $chat_object->setCreatedOn(date("Y-m-d h:i:s"));
            $chat_object->save_chat(); // save_chat() method returns a Boolean (true or false)



            $user_object = new \ChatUser;

            $user_object->setUserId($data['userId']); // 'userId' which came from the client side (JavaScript) in chatroom.php using the    conn.send()    function (Under the "Handling Chat HTML Form Submission" Section in chatroom.php)
            $user_data = $user_object->get_user_data_by_id();

            $user_name  = $user_data['user_name']; // We get the $user_name of the message sender and the time when that message was sent (to send them to the client side as JSON in order to display them on the client side using JavaScript)
            $data['dt'] = date("d-m-Y h:i:s");     // We get the $user_name of the message sender and the time when that message was sent (to send them to the client side as JSON in order to display them on the client side using JavaScript)



            foreach ($this->clients as $client) {
                // Note: This following if condition allows sending the message to the receivers ONLY, meaning it doesn't send the message to the original sender (because they (the sender) already are the sender), but it sends it to just the receivers only. (N.B. Sending is for the client side (JavaScript in chatroom.php))
                /*if ($from !== $client) { // N.B. Don't show (send) the sent message to the original sender of this message! But show (send) it to the receivers only! (N.B. Sending is for the client side (JavaScript in chatroom.php))
                    // The sender is not the receiver, send to each client connected
                    $client->send($msg); // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in chatroom.php
                }*/

                // Note: Here we send the message to BOTH the sender and receivers (but in case of the current user is the original sender, we include    $data['from'] = 'Me'    with the message (i.e. $data variable) sent to the client side, and in case of the current user is not the sender of that message (a receiver), we include    $data['from'] = $user_name;    with the message (i.e. $data variable) sent to the client side)
                // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                if ($from == $client) // If the user is the original sender of the messsage (i.e. Send/Make    $data['from'] = 'Me'    for the original sender of the message, and Send/make it    $data['from'] = $user_name;    for the rest of the receivers of that message)
                {
                    $data['from'] = 'Me'; // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }
                else // If the user is NOT the sender of the message (they are just a receiver) (i.e. Send/Make    $data['from'] = 'Me'    for the original sender of the message, and send/make it    $data['from'] = $user_name;    for the rest of the receivers of that message)
                {
                    $data['from'] = $user_name;  // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
                }

                // Send the $data variable (the message and other data) to the client side (Check the <script> tag in chatroom.php)
                $client->send(json_encode($data)); // The sender is not the receiver, send to each client connected    // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in chatroom.php    // Include the chat message sender name in the $data array to eventually convert it to JSON and send it to the client side (to be received by JavaScript)
            }
        }
    }

    public function onClose(ConnectionInterface $conn) {

        // Disply the Online/Offline Status of all users/clients based on the onOpen() and onClose() methods (in case of 'One-to-One/Private' Chat ONLY, not 'Group' Chat. With 'Group' Chat, we depended on the `user_login_status` column of `chat_user_table` table) (This script is repeated inside the onOpen() method of this class too for the Online/Offline Status too (Offline Status))
        // Note: We have the same script in onOpen() method for the 'Online' Status. Check the onOpen() method for the same script (and better explanation)
        // Note: With the 'Group' Chat (in chatroom.php), we depended on the `user_login_status` column of `chat_user_table` table to display the Online/Offline Status of all users/clients, but with the 'One-to-One/Private' Chat (in privatechat.php), we depended on the onOpen() and onClose() methods here to send the `user_id` user id and status 'Online' or 'Offline to all users/clients on the Client Side (to be handled by JavaScript in privatechat.php inside the    conn.onmessage = function(event) {    ). And of cousre, depending on the onOpen() is the best option because it means the Online/Offline is live and instantaneous, unlike the case with depending on the `user_login_status` column
        // Note: For displaying User Online/Offline Status, with 'One-to-One/Private' Chat, we depended on the onOpen() and onClose() methods of the custom WebSocket handler Chat.php class (which is the best way because it's Real-time and Instantaneous), but with the 'Group' Chat, we depended on the `user_login_status` column of the `chat_user_table` database table (which is a bad idea, because a user can just close the browser and don't click on Logout, and if they don't click on Logout, the `user_login_status` column value won't be changed, then their Online/Offline Status will be always 'Online').
        // Note: Sending data from the onOpen() and onClose() methods of the custom WebSocket Handler Chat.php Class triggers the    conn.onmessage    event in JavaScript on the client side (here in this project, in privatechat.php or chatroom.php) (i.e. It doesn't trigger the    conn.onopen    or    conn.onclose    JavaScript events!)
        $querystring = $conn->httpRequest->getUri()->getQuery();

        parse_str($querystring, $queryarray);

        if (isset($queryarray['token'])) // Display User Online/Offline Status in case of 'One-to-One/Private' Chat    
        {
            $user_object = new \ChatUser;

            $user_object->setUserToken($queryarray['token']);
            $user_data = $user_object->get_user_id_from_token();
            $user_id = $user_data['user_id'];

            $data['status_type'] = 'Offline';   // Append 'status_type'    to the $data array to be sent to the client side to display real-time User Online/Offline Status
            $data['user_id_status'] = $user_id; // Append 'user_id_status' to the $data array to be sent to the client side to display real-time User Online/Offline Status

            foreach ($this->clients as $client)
            {
                // Important: Sending this $data array variable (using    $client->send(json_encode($data));    ) from onOpen() or onClose() methods here (we're on the server-side) triggers the    conn.onmessage    event on the client side (JavaScript) in privatechat.php i.e.    conn.onmessage = function(e) {
                $client->send(json_encode($data)); // $data is then parsed to a JavaScript Object by JavaScript by the    conn.onmessage    in chatroom.php
            }
        }

        // The connection is closed, remove it, as we can no longer send it messages
        $this->clients->detach($conn);

        echo "Connection {$conn->resourceId} has disconnected\n";
    }

    public function onError(ConnectionInterface $conn, \Exception $e) {
        echo "An error has occurred: {$e->getMessage()}\n";

        $conn->close();
    }
}

?>